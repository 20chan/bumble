# Macro Function

주말에 피시방에서 오버워치하다가 갑자기 떠오른 아이디어라서 정리가 잘 되지 않았습니다.
기본적으로 루비의 &에 바탕을 두고 있습니다.

매크로는 동적으로 코드 추가를 함수 사용처럼 해줍니다 (??)
예를 들어, 변수 `a`의 `length` 멤버변수가 어떠한 값을 리턴한다고 할 때,
```
var macro1 = #(:length);

macro1(a);
```
이 때 `macro1(a)`는 `a.length`와 동일한 코드입니다.
이는 map같은 고계함수를 사용하기 쉽게 해줍니다.
```
map(#(:length), [[1, 2, 3], [4, 5, 6], [7, 8]]);
// [a.length for a in [[1, 2, 3], [4, 5, 6], [7, 8]]] 와 같은 코드
```

매크로는 단순한 코드 치환에 불과합니다. 예를 들어, 다음과 같은 매크로 `plus_macro`가 있다고 합시다.

```
var plus_macro = #(:+=1);
a, b, c = 1, 2, 3;
map(plus_macro, [&a, &b, &c]);
print(a, b, c);
```

위 코드는 2, 3, 4를 출력할 것입니다.

## 추가

기존의 생각은 `#(:length)` 대신 `#(.length)`를 사용할 생각이었다.
매크로 함수가 단순히 인자의 뒤에 코드를 붙여주는 개념으로 구상을 했는데,
다음과 `[a1, a2, a3]` 에 `[new A(a1.b), new A(a2.b), new A(a3.b)]`와 같은 코드를 생성하기엔 문제가 있다 생각하여
루비의 신택스를 참고하여 비슷하게 변경하였다.

그래서 지금은 위 예제는 다음과 같이 구현할 수 있다.
```python
var aaa = [a1, a2, a3];
var AAA = map(#(new A(:b)))
// [new A(a.b) for a in aaa] 와 같은 코드이다
```

만약, `list comprehension이 있는데 굳이 이렇게 해야 하나요..?`
라고 하면 루비의 &와는 다르다고 말할 수 있습니다.

여기서 매크로 함수는 하나의 callable한 오브젝트입니다. 람다나 함수처럼 취급되는 것으로 유용하게 사용될 수 있죠! ~~아마도~~ ~~나무위키 꺼라~~[1][2][3]
